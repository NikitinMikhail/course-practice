Игра "Поймай шарик"
###################

:date: 2019-10-07 09:00
:summary: Графическая библиотека Tkinter и простые виджеты.
:status: publish

.. default-role:: code
.. contents:: Содержание


Пользовательский интерфейс
============

Что такое Tkinter

Tkinter – это пакет для Python, предназначенный для работы с библиотекой Tk. Библиотека Tk содержит компоненты графического интерфейса пользователя (graphical user interface – GUI), написанные на языке программирования Tcl.

Под графическим интерфейсом пользователя (GUI) подразумеваются все те окна, кнопки, текстовые поля для ввода, скроллеры, списки, радиокнопки, флажки и др., которые вы видите на экране, открывая то или иное приложение. Через них вы взаимодействуете с программой и управляете ею. Все эти элементы интерфейса вместе будем называть виджетами (widgets).

В настоящее время почти все приложения, которые создаются для конечного пользователя, имеют GUI. Редкие программы, подразумевающие взаимодействие с человеком, остаются консольными. В предыдущих двух курсах мы писали только консольные программы.

Существует множество библиотек GUI. Tk далеко не самая популярная, хотя с ее использованием написано не мало проектов. Однако по ряду причин она была выбрана для Python по-умолчанию. Установочный файл Питона обычно уже включает пакет tkinter в составе стандартной библиотеки наряду с другими модулями.

Не вдаваясь в подробности, Tkinter можно охарактеризовать как переводчик с языка Python на язык Tcl. Вы пишете программу на Python, а код модуля tkinter у вас за спиной переводит ваши инструкции на язык Tcl, который понимает библиотека Tk.

Приложения с графическим интерфейсом пользователя событийно-ориентированные. Вы уже должны иметь представление о структурном и желательно объектно-ориентированном программировании. Событийно-ориентированное ориентировано на события. То есть та или иная часть программного кода начинает выполняться лишь тогда, когда случается то или иное событие.

Событийно-ориентированное программирование базируется на объектно-ориентированном и структурном. Даже если мы не создаем собственных классов и объектов, то все-равно ими пользуемся. Все виджеты – объекты, порожденные встроенными классами.

События бывают разными. Сработал временной фактор, кто-то кликнул мышкой или нажал Enter, начал вводить текст, переключил радиокнопки, прокрутил страницу вниз и т. д. Когда случается что-то подобное, то, если был создан соответствующий обработчик, происходит срабатывание определенной части программы, что приводит к какому-либо результату.

Tkinter импортируется стандартно для модуля Python любым из способов: `import tkinter`, `from tkinter import *`, `import tkinter as tk`. Можно импортировать отдельные классы, что делается редко. В данной работе будет в основном использоваться `from tkinter import *`.

Далее, чтобы написать GUI-программу, надо выполнить приблизительно следующее:

#. Создать главное окно.
#. Создать виджеты и выполнить конфигурацию их свойств (опций).
#. Определить события, то есть то, на что будет реагировать программа.
#. Определить обработчики событий, то есть то, как будет реагировать программа.
#. Расположить виджеты в главном окне.
#. Запустить цикл обработки событий.

Последовательность не обязательно такая, но первый и последний пункты всегда остаются на своих местах. Посмотрим все это в действии.

В окне, которое можно назвать главным, располагаются все остальные виджеты. Объект окна верхнего уровня создается от класса Tk модуля tkinter. Переменную, связываемую с объектом, часто называют root (корень):

.. code-block:: python

   root = Tk()


Пусть в окне приложения располагаются текстовое поле (entry), метка (label) и кнопка (button). Данные объекты создаются от соответствующих классов модуля tkinter. Мы сразу сконфигурируем некоторые их свойства с помощью передачи аргументов конструкторам этих классов:

.. code-block:: python

   e = Entry(root, width=20)
   b = Button(root, text="Преобразовать")
   l = Label(root, bg='black', fg='white', width=20)

Устанавливать свойства объектов не обязательно при из создании. Существуют еще пара способов, с помощью которых можно это сделать после.

Обратите внимание, что первым аргументом указывается "хозяин, мастер" – место, где располагается виджет. В данном случае его можно было не указывать. Однако виджеты не обязательно располагаются на root'е. Они могут размещаться в других виджетах.

Пусть в программе текст, введенный человеком в поле, при нажатии на кнопку разбивается на список слов, слова сортируются по алфавиту и выводятся в метке. Код выполняющий все это надо поместить в функцию:

.. code-block:: python

   def strToSortlist(event):
       s = e.get()
       s = s.split()
       s.sort()
       l['text'] = ' '.join(s)

У функций, которые вызываются при наступлении события с помощью метода bind(), должен быть один параметр. Обычно его называют event (событие).

В приведенной функции с помощью метода get() из поля забирается текст, представляющий собой строку. Она преобразуется в список слов с помощью метода split(). Потом список сортируется. В конце изменяется свойство text метки. Ему присваивается строка, полученная из списка с помощью строкового метода join().

Теперь необходимо связать вызов функции с событием:

.. code-block:: python

   b.bind('<Button-1>', strToSortlist)

В данном случае это делается с помощью метода bind(). Ему передается событие и вызываемая функция. Событие будет передано в функцию и присвоено параметру event. В данном случае событием является щелчок левой кнопкой мыши, что обозначается строкой '<Button-1>'.

В любом приложении виджеты не разбросаны по окну как попало, а хорошо организованы, интерфейс продуман до мелочей и обычно подчинен определенным стандартам. Пока расположим элементы друг за другом с помощью наиболее простого менеджера геометрии tkinter – метода pack():

.. code-block:: python

   e.pack()
   b.pack()
   l.pack()

Метод mainloop() объекта Tk запускает главный цикл обработки событий, что в том числе приводит к отображению главного окна со всеми его причиндалами на экране:

.. code-block:: python

   root.mainloop()

Полный код программы:

.. code-block:: python

   from tkinter import *
    
   root = Tk()
    
   e = Entry(width=20)
   b = Button(text="Преобразовать")
   l = Label(bg='black', fg='white', width=20)
    
   def strToSortlist(event):
       s = e.get()
       s = s.split()
       s.sort()
       l['text'] = ' '.join(s)
    
   b.bind('<Button-1>', strToSortlist)
    
   e.pack()
   b.pack()
   l.pack()
   root.mainloop()

В результате выполнения данного скрипта появляется окно, в текстовое поле которого можно ввести список слов, нажать кнопку и получить его отсортированный вариант.


Виджет Canvas
=============

В tkinter от класса Canvas создаются объекты-холсты, на которых можно "рисовать", размещая различные фигуры и объекты. Делается это с помощью вызовов соответствующих методов.

При создании экземпляра Canvas необходимо указать его ширину и высоту. При размещении геометрических примитивов и других объектов указываются их координаты на холсте. Точкой отсчета является верхний левый угол.

В программе ниже создается холст. На нем с помощью метода create_line() рисуются отрезки. Сначала указываются координаты начала (x1, y1), затем – конца (x2, y2).

.. code-block:: python

   from tkinter import *
   root = Tk()

   c = Canvas(root, width=200, height=200, bg='white')
   c.pack()

   c.create_line(10, 10, 190, 50)

   c.create_line(100, 180, 100, 60, fill='green',
                   width=5, arrow=LAST, dash=(10,2),
                   activefill='lightgreen',
                   arrowshape="10 20 10")

   root.mainloop()


Остальные свойства являются необязательными. Так activefill определяет цвет отрезка при наведении на него курсора мыши.

Создание прямоугольников методом create_rectangle():

.. code-block:: python

   …
   c.create_rectangle(10, 10, 190, 60)

   c.create_rectangle(60, 80, 140, 190, fill='yellow', outline='green',
                       width=3, activedash=(5, 4))
   …


Первые координаты – верхний левый угол, вторые – правый нижний. В приведенном примере, когда на второй прямоугольник попадает курсор мыши, его рамка становится пунктирной, что определяется свойством activedash.

Методом create_polygon() рисуется произвольный многоугольник путем задания координат каждой его точки:

.. code-block:: python

   …
   c.create_polygon(100, 10, 20, 90, 180, 90)

   c.create_polygon(40, 110, 160, 110, 190, 180, 10, 180,
                   fill='orange', outline='black')
   …


Для удобства координаты точек можно заключать в скобки:

.. code-block:: python

   …
   c.create_polygon((40, 110), (160, 110), (190, 180), (10, 180),
                   fill='orange', outline='black')
   …

Метод create_oval() создает эллипсы. При этом задаются координаты гипотетического прямоугольника, описывающего эллипс. Если нужно получить круг, то соответственно описываемый прямоугольник должен быть квадратом.

.. code-block:: python

   …
   c.create_oval(50, 10, 150, 110, width=2)
   c.create_oval(10, 120, 190, 190, fill='grey70', outline='white')
   …

Более сложные для понимания фигуры получаются при использовании метода create_arc(). В зависимости от значения опции style можно получить сектор (по умолчанию), сегмент (CHORD) или дугу (ARC). Также как в случае create_oval() координаты задают прямоугольник, в который вписана окружность (или эллипс), из которой "вырезают" сектор, сегмент или дугу. Опции start присваивается градус начала фигуры, extent определяет угол поворота.

.. code-block:: python

   …
   c.create_oval(10, 10, 190, 190, fill='lightgrey', outline='white')
   c.create_arc(10, 10, 190, 190, start=0, extent=45, fill='red')
   c.create_arc(10, 10, 190, 190, start=180, extent=25, fill='orange')
   c.create_arc(10, 10, 190, 190, start=240, extent=100, style=CHORD, fill='green')
   c.create_arc(10, 10, 190, 190, start=160, extent=-70, style=ARC, outline='darkblue', width=5)
   …

На холсте можно разместить текст. Делается это с помощью метода create_text():

.. code-block:: python

   …
   c.create_text(100, 100, text="Hello World,\nPython\nand Tk",
                   justify=CENTER, font="Verdana 14")
   c.create_text(200, 200, text="About this",
                   anchor=SE, fill="grey")
   …

По умолчанию в заданной координате располагается центр текстовой надписи. Чтобы изменить это и, например, разместить по указанной координате левую границу текста, используется якорь со значением W (от англ. west – запад). Другие значения: N, NE, E, SE, S, SW, W, NW. Если букв, задающих сторону привязки, две, то вторая определяет вертикальную привязку (вверх или вниз «уйдет» текст от заданной координаты). Свойство justify определяет лишь выравнивание текста относительно себя самого.


Заготовка игры "Поймай шарик"
=============================

Для создания игр разумнее использовать специальные библиотеки (движки), хотя бы Pygame, которые уже содержат такие вещи, как двойная буферизация, работа с спрайтами и т.д. Но первые «игры» мы будем создать с помощью tkinter, потому что цель — научится программировать (в Python), а не создать готовый продукт (игру). Для этой цели простой и понятный tkinter подходит больше, чем сложные, хотя и богатые по возможностям игровые движки.

Суть игры проста: в случайном месте появляется на короткое время шарик и мы должны успеть щелкнуть по нему мышкой.

Вначале создадим появляющиеся шарики:

.. code-block:: python

   from tkinter import *
   from random import randrange as rnd, choice
   import time
   root = Tk()
   root.geometry('800x600')
    
   canv = Canvas(root,bg='white')
   canv.pack(fill=BOTH,expand=1)
    
   colors = ['red','orange','yellow','green','blue']
   def new_ball():
       canv.delete(ALL)
       x = rnd(100,700)
       y = rnd(100,500)
       r = rnd(30,50)
       canv.create_oval(x-r,y-r,x+r,y+r,fill = choice(colors), width=0)
       root.after(1000,new_ball)
        
   new_ball()
   mainloop()

Теперь добавим обработку щелчка мыши. Для начала выведем что-нибудь в консоль:

.. code-block:: python

   from tkinter import *
   from random import randrange as rnd, choice
   import time
   root = Tk()
   root.geometry('800x600')
    
   canv = Canvas(root,bg='white')
   canv.pack(fill=BOTH,expand=1)
 
   colors = ['red','orange','yellow','green','blue']
   def new_ball():
       canv.delete(ALL)
       x = rnd(100,700)
       y = rnd(100,500)
       r = rnd(30,50)
       canv.create_oval(x-r,y-r,x+r,y+r,fill = choice(colors), width=0)
       root.after(1000,new_ball)
        
        
   def click(event):
       print('click')   
        
   new_ball()
   canv.bind('<Button-1>', click)
   mainloop()

При каждом щелчке в консоли будет появляться надпись «click».

Чтобы определить, попали ли мы в круг, нужно знать его координаты, радиус круга и координаты мыши в момент щелчка. Координаты мыши легко получить через event.x, event.y. Попробуем получить координаты круга:

.. code-block:: python

   def click(event):
       print(x,y,r)  

Такой способ не прошел. Почему? В чем суть появившегося сообщения об ошибке, что оно означает?

Исправим ситуацию:

.. code-block:: python

   def new_ball():
       global x,y,r
       canv.delete(ALL)
       x = rnd(100,700)
       y = rnd(100,500)
       r = rnd(30,50)
       canv.create_oval(x-r,y-r,x+r,y+r,fill = choice(colors), width=0)
       root.after(1000,new_ball)
        
        
   def click(event):
       print(x,y,r)   

Использование global – это не самое лучшее решение. Для данной задачи больше подходит использование ООП (объектно-ориентированного подхода), но об этом позже. А пока – будем использовать global.

global означает, что переменные будут считаться глобальными (а не локальными), т.е. их значение сохранится и после завершения работы функции, а не будет уничтожено, как это произойдет со всеми локальными переменными.

Осталось проверить, не лежит ли точка `(event.x, event.y)` дальше, чем r от точки `(x,y)`. Для этого, с помощью теоремы Пифагора мы найдем расстояние между двумя точками и сравним с радиусом круга.

Задания
-------

1. Сделать код читабельным и документированным.
2. Реализовать подсчёт очков.
3. Сделать шарики двигающимися со случайным отражением от стен.
4. Реализовать одновременное присутствие нескольких шариков на экране.
5. * Добавить второй тип мишени со своей формой и своим специфическим харктером движения.
6. * Выдавать за эти мишени другое количество очков.
7. * Сделать таблицу лучших игроков, авматически сохраняющуюся в файл.


