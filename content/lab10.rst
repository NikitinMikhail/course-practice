Игра "Пушка". Продолжение
###########################

:date: 2019-10-21
:summary: Сохранение игры. Переход к событийной парадигме.
:status:
:lecture_link: https://youtu.be/904N6TyNabw

.. default-role:: code
.. contents:: Содержание

Методы `after()` и `after_cancel()`
===================================

Текущая версия игры "Пушка" управляется с помощью функции `new_game()`, в которой важную роль играют глобальные переменные. Такой подход редко используется в ООП и при работе с Tkinter в частности. Циклы внутри функции `new_game()` дублируют `root.mainloop()`, поэтому от них лучше отказаться в пользу метода `after()`. 

Так как пули и цели должны иногда удаляться из приложения, полезно знать, как можно отменить запланированный с помощью `after()` вызов функции. Метод `after()` возвращает идентификатор задания `job`, и если передать `job` методу `after_cancel()`, то задание не будет выполнено. 

Попробуйте следующий пример:

.. code-block:: python

    from tkinter import *
    
    
    def control():
        if done:
            print('stopping..')
            root.after_cancel(job)
        else:
            root.after(100, control)
    
    
    def task():
        global done, job
        print("Task is done!")
        done = True
        job = root.after(500, task)
    
    
    root = Tk()
    done = False
    job = root.after(500, task)
    root.after(100, control)
    
    print("Так выглядит идентификатор задания\ntype: {}\nvalue: {}\n".format(
        type(job), job))
    
    root.mainloop()
    
После одной итерации `task()` отложенное задание отменилось, благодаря `after_cancel()`. С идентификаторами заданий удобно работать, так как они являются обычными строками.


Архитектура приложений в Tkinter
=================================

Стандартное решение -- использовать виджеты не только для создания графического интерфейса, но и для хранения данных и реализации алгоритмов. Это достигается наследованием своих классов от виджетов Tkinter. Например:

.. code-block:: python

    from tkinter import *
    
    class BattleField(Canvas):
        def __init__(self, master):
            super().__init__(master)
            self.gun = 'foo'
            print(self.master.my_data)
    
    class Application(Tk):
        def __init__(self, my_data):
            # С помощью `super()` вызывают методы родительских классов
            # Вызов `__init__()` родителя важен, так как соединяет объект
            # с родительским виджетом.
            super().__init__()
            self.my_data = my_data
            self.battlefield = BattleField(self)
            self.battlefield.pack()
    
    app = Application('bar')
    app.mainloop()

Здесь `battlefield` -- атрибут `app`, так как виджет для рисования находится внутри окна приложения. Такой порядок хранения виджетов логичен: объект, задающий большой виджет, содержит в себе в качестве атрибутов маленькие виджеты. В свою очередь виджеты-атрибуты получают доступ к большому виджету (хозяину) через свой атрибут `master`. 

Новая "Пушка"
=================================

Алгоритм нового решения реализован внутри объекта класса `BattleField`, который наследует классу `Canvas`.'
 
1. В объекте класса `BattleField` "живут" пушка, пули и цели. У каждого из этих объектов есть метод `update()`, который запущен в неявном цикле `after()`. Метод `update()` обеспечивает движение объектов.
2. Метод `BattleField.catch_victory()` определяет моменты времени, в которые все цели уничтожены. В такие моменты моменты `BattleField.catch_victory()` обновляет набор целей и показывает сообщение с информацией о том, сколько выстрелов потребовалось игроку.

Абстрактные классы
=================================

Абстрактный метод -- это метод, который нельзя вызвать и который обязательно должен быть переопределен в классе потомке. Абстрактные методы нужны, чтобы программист не забыл определить один или несколько методов. 

Абстрактный класс -- это класс, у которого есть по крайней мере один абстрактный метод. У абстрактных классов не может быть своих экземпляров и поэтому они служат родителями другим классам.

На практике возникают классы, у которых не должно быть экземпляров. Рассмотрим множество живых организмов. Млекопитающие -- класс с четкими критериями и определенными свойствами, но он все же слишком общий, чтобы создавать его экземпляры. Логично будет сделать млекопитающих абстракным классом (или абстракцией), а создание экземпляров оставить на классы, описывающие конкретные  виды, например на класс барсуков или енотов. 

В Python абстрактные классы создаются с помощь модуля `abc`.

.. code-block:: python

    import abc
    
    
    class Mammal(abc.ABC):
        @abc.abstractmethod
        def move(self):
            pass
    
    
    class Dolphin(Mammal):
        def move(self):
            print('I am swimming!')
    
    
    class Bat(Mammal):
        pass
    
    
    d = Dolphin()  # ok
    d.move()       # ok
    
    # Error. Метод `move()` не переопределен, 
    # поэтому `Bat` -- абстрактный и не может иметь экземпляров. 
    b = Bat()      


В новой реализации игры "Пушка" пули, цели и пушка похожи, поэтому для них был заведен абстрактный класс `Agent`.


Упражнения
===========

Код с новой "Пушкой" лежит в репозитории https://github.com/mipt-cs/course-practice.git в папке content/code/lab10 в ветке lab10.

Упражнение №1
+++++++++++++

Дописать методы, помеченные комментариями `TODO`, так, чтобы программа нормально работала.

Упражнение №2
+++++++++++++

Добавить в новое приложение игровую механику, которая есть в Вашей старой версии "Пушки".



